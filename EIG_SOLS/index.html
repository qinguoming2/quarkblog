<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta name="generator" content="Quarkdown">
    <meta charset="UTF-8">
    <meta name="description" content="a blog demo">
    <meta name="author" content="qinguoming">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="quarkdown:root-path" content="..">
    <title>blog</title>
    <script src="../script/quarkdown.js"></script>
    <script>const capabilities = window.quarkdownCapabilities</script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css" rel="stylesheet">
    <link href="../theme/theme.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" rel="stylesheet" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" defer="true" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script>
    <script>capabilities.math = true;

window.texMacros = {}</script>
    <style>@font-face { font-family: '-503305824'; src: local('Consolas'); }

body {
    --qd-code-custom-font: '-503305824';
    --qd-main-font-size: 12.0pt;}

body.quarkdown-plain.quarkdown-plain,
body.quarkdown-docs.quarkdown-docs {
}

body.quarkdown-slides.quarkdown-slides .reveal {
}

@page {
    size: auto auto;
    margin: 0;}

p {
}</style>
    <script>prepare(new PlainDocument());</script>
<template id="sidebar-template"><nav class="sidebar" role="doc-toc"><ol><li data-target-id="特征值问题数值解" data-depth="1" data-location="1"><a href="#特征值问题数值解">特征值问题数值解</a><ol><li data-target-id="介绍" data-depth="2" data-location="1.1"><a href="#介绍">介绍</a></li><li data-target-id="标准特征值问题" data-depth="2" data-location="1.2"><a href="#标准特征值问题">标准特征值问题</a></li><li data-target-id="标准特征值的数值解" data-depth="2" data-location="1.3"><a href="#标准特征值的数值解">标准特征值的数值解</a><ol><li data-target-id="jacobi-method" data-depth="3" data-location="1.3.1"><a href="#jacobi-method">Jacobi Method</a></li><li data-target-id="power-method" data-depth="3" data-location="1.3.2"><a href="#power-method">Power Method</a></li></ol></li><li data-target-id="瑞利里兹-子空间迭代法" data-depth="2" data-location="1.4"><a href="#瑞利里兹-子空间迭代法">瑞利里兹-子空间迭代法</a><ol><li data-target-id="step01" data-depth="3" data-location="1.4.1"><a href="#step01">Step01</a></li><li data-target-id="step02" data-depth="3" data-location="1.4.2"><a href="#step02">Step02</a></li><li data-target-id="step03" data-depth="3" data-location="1.4.3"><a href="#step03">Step03</a></li></ol></li></ol></li></ol></nav>
</template>  </head>
  <body class="quarkdown quarkdown-plain">
    <aside class="margin-area" id="margin-area-left"></aside>
    <main><div class="page-break" data-hidden=""></div><h1 id="table-of-contents">目录</h1><nav role="table-of-contents" data-role="table-of-contents"><ol><li data-target-id="特征值问题数值解" data-depth="1" data-location="1"><a href="#特征值问题数值解">特征值问题数值解</a><ol><li data-target-id="介绍" data-depth="2" data-location="1.1"><a href="#介绍">介绍</a></li><li data-target-id="标准特征值问题" data-depth="2" data-location="1.2"><a href="#标准特征值问题">标准特征值问题</a></li><li data-target-id="标准特征值的数值解" data-depth="2" data-location="1.3"><a href="#标准特征值的数值解">标准特征值的数值解</a><ol><li data-target-id="jacobi-method" data-depth="3" data-location="1.3.1"><a href="#jacobi-method">Jacobi Method</a></li><li data-target-id="power-method" data-depth="3" data-location="1.3.2"><a href="#power-method">Power Method</a></li></ol></li><li data-target-id="瑞利里兹-子空间迭代法" data-depth="2" data-location="1.4"><a href="#瑞利里兹-子空间迭代法">瑞利里兹-子空间迭代法</a><ol><li data-target-id="step01" data-depth="3" data-location="1.4.1"><a href="#step01">Step01</a></li><li data-target-id="step02" data-depth="3" data-location="1.4.2"><a href="#step02">Step02</a></li><li data-target-id="step03" data-depth="3" data-location="1.4.3"><a href="#step03">Step03</a></li></ol></li></ol></li></ol></nav><div class="container fullwidth" style="justify-items: end; text-align: end;"><p><a href="https://qinguoming.pages.dev/">返回 主页</a></p></div><div class="page-break" data-hidden=""></div><h1 id="特征值问题数值解" data-location="1">特征值问题数值解</h1><h2 id="介绍" data-location="1.1">介绍</h2><p>当使用FEM求解特征值问题时,一般可以表述为:</p><figure><img src="media/img-20250317172303@-1402763006.png" alt="Img" /></figure><p>在大多数工程问题中,A,B一般是对称矩阵;如果要求的问题是结构自由振动,那么A对应刚度矩阵K;B对应质量矩阵M; <formula>\lambda</formula> 是特征值; <formula>\vec{X}</formula> 是特征向量或称为模态振型.假设A,B已经引入边界条件.</p><p>上式可重写为:</p><figure><img src="media/img-20250317172813@-1229485850.png" alt="Img" /></figure><p>有解:</p><figure><img src="media/img-20250317172855@-1115276444.png" alt="Img" /></figure><p>可知,当且仅当系数矩阵行列式为0,方程才有非0解,即:</p><figure><img src="media/img-20250317173021@2030013562.png" alt="Img" /></figure><p>将行列式展开可得到关于 <formula>\lambda</formula> 的n次多项式,其根就是特征值 <formula>\lambda_i</formula> ,把 <formula>\lambda_i</formula> 带入方程可以求得 <formula>\vec{X}_i</formula> .这称为特征对.根据矩阵论, <formula>X_j</formula> 是特征向量,那么n个特征向量的线性组合也是特征向量.</p><p>在商软中,有一种归一化方法是,每个特征向量的最大值归一化为1.0,这称为<em><strong>位移归一化</strong></em>.如下:</p><figure><img src="media/img-20250317173617@-1260346295.png" alt="Img" /></figure><p>另一种归一化称为质量归一,满足:</p><figure><img src="media/img-20250317173910@1397795461.png" alt="Img" /></figure><h2 id="标准特征值问题" data-location="1.2">标准特征值问题</h2><p>特征值问题分为广义特征值问题和标准特征值问题.广义特征值问题形如:</p><figure><img src="media/img-20250317172303@-1402763006.png" alt="Img" /></figure><p>标准特征值问题形如:</p><figure><img src="media/img-20250317174148@429113921.png" alt="Img" /></figure><p>求解广义特征值的第一步是转换为标准特征值问题:</p><formula data-block="">[A]X=\lambda [B]X \Rightarrow [B]^{-1}[A]X=\lambda X \tag{1}</formula><p>虽然A,B一般是对称矩阵,但 <formula>H=B^{-1}A</formula> 一般则不对称.可以利用choleski分解得到对称的H矩阵.假设B是对称正定矩阵,则 <formula>B=U^TU</formula></p><p>B带入公式1后:</p><figure><img src="media/img-20250317174936@-1091354714.png" alt="Img" /></figure><p>定义 <formula>\vec{Y}=U\vec{X}</formula> ,则有:</p><formula data-block="">([H]-\lambda[I]) \vec{Y}=\overrightarrow{0}\tag{2}</formula><p>[H]是对称矩阵,即:</p><formula data-block="">[H]=\left([U]^{T}\right)^{-1}[A][U]^{-1}</formula><p>求解公式2中的 <formula>\lambda_i</formula> 和 <formula>\vec{Y_i}</formula> 后, <formula>\vec{X_i}=U^{-1}\vec{Y}</formula> .</p><h2 id="标准特征值的数值解" data-location="1.3">标准特征值的数值解</h2><p>求解方法分类:</p><ul><li>transformation methods<ul><li>Jacobi method</li><li>Givens method</li><li>Householder method</li><li>etc</li></ul></li><li>iterative methods<ul><li>power method</li><li>etc</li></ul></li></ul><p>transformation methods适合用于求所有特征值对;迭代法适合求解少数几个特征值对.</p><h3 id="jacobi-method" data-location="1.3.1">Jacobi Method</h3><p>solving:</p><figure><img src="media/img-20250317175937@650377990.png" alt="Img" /></figure><p>Jacobi方法基于: 实对称矩阵H只有实特征值 <formula>\lambda_i</formula> ,且存在实正交矩阵P,P满足 <formula>P^THP=diag\{\lambda_i\}</formula> ,P矩阵的列是特征向量.</p><p>P矩阵可以由一系列形如下式的旋转矩阵的乘积而得到.</p><figure><img src="media/img-20250317180538@-533319125.png" alt="Img" /></figure><p><formula>[P_1]</formula> 中除了第i列和第j行中的元素外,所有元素都与单位矩阵 <formula>I</formula> 中的元素相同.如果Sin值和Cos值出现在(i, i),(i, j), (j, i),(j, j), 那 <formula>[P_1]^TH[P]</formula> 的对应元素为:</p><figure><img src="media/img-20250317181036@1064855747.png" alt="Img" /></figure><p><formula>\theta</formula> 满足:</p><figure><img src="media/img-20250317181055@1121223326.png" alt="Img" /></figure><p>然后令 <formula>h_{ij}=h_{ji}=0</formula> .因此在Jacobi法每一步中都会<strong>令一对非对角元素为0.0</strong>;在下一步中,虽然该方法减少了一对新的零,但它引入了非零的贡献到以前的零位置.在下一步中使用下入下式的矩阵[H_i]代替[H]:</p><figure><img src="media/img-20250317182659@-396914455.png" alt="Img" /></figure><p>关于每一步的i,j选择:每一步开始时,可以选取[H_i]非对角元素的最大值所在的i,j;一直迭代到H_i矩阵非对角元素全为0.0,或小于某个阈值.</p><p>最后的特征向量矩阵 <formula>P=P_1P_2P_3...</formula></p><p>以上时jacobi法的基本操作,由此衍生了循环jacobi,过关jacobi等方法.</p><blockquote><p><a href="https://www.cnblogs.com/tlnshuju/p/6726000.html">https://www.cnblogs.com/tlnshuju/p/6726000.html</a>
<a href="https://zhuanlan.zhihu.com/p/262879394">https://zhuanlan.zhihu.com/p/262879394</a>
<a href="https://blog.csdn.net/qq_43133135/article/details/126502543">https://blog.csdn.net/qq_43133135/article/details/126502543</a></p></blockquote><h3 id="power-method" data-location="1.3.2">Power Method</h3><h4 id="计算最大特征值">计算最大特征值</h4><p>power method是求解最大特征值或主特征值( <formula>\lambda_1</formula> )和对应特征向量 <formula>\vec{X_1}</formula> 的最简单的迭代法.假设H为实对称矩阵,存在N个独立特征向量;</p><p>首先,选择初始向量 <formula>\vec{Z_0}</formula> ,通过迭代生成一系列向量 <formula>\vec{Z_1},\vec{Z_2}....</formula> :</p><figure><img src="media/img-20250317183848@-1203950296.png" alt="Img" /></figure><p>因此,p-th向量有:</p><figure><img src="media/img-20250317183951@-293945981.png" alt="Img" /></figure><p>在第p次迭代会得到 <formula>Z_p</formula> ,如果满足:</p><figure><img src="media/img-20250317184607@-1351491448.png" alt="Img" /></figure><p>则停止迭代. <formula>z_{p,j}, z_{p-1,j}</formula> 表示 <formula>Z_p</formula> 和 <formula>Z_{p-1}</formula> 的第j个分量. <formula>\lambda_1</formula> 是要求的特征值;</p><p><strong>收敛性解释如下</strong></p><p>Z0向量可以表示为特征向量得到线性组合:</p><figure><img src="media/img-20250317185145@359577788.png" alt="Img" /></figure><p>如果 <formula>\lambda_i</formula> 是 <formula>X_i</formula> 对应的特征值,则:</p><figure><img src="media/img-20250317185201@1128542847.png" alt="Img" /></figure><figure><img src="media/img-20250317185238@1221247939.png" alt="Img" /></figure><figure><img src="media/img-20250317185259@1281165952.png" alt="Img" /></figure><p>根据以上,当p=+inf,则:</p><figure><img src="media/img-20250317185343@2134794556.png" alt="Img" /></figure><p>因此取 <formula>H^pZ_0</formula> 和 <formula>H^{p-1}Z_0</formula> 的任一分量相除,应该有相同的极限值 <formula>\lambda_1</formula> ,【这可以作为停止迭代的标志】,进一步:</p><formula data-block="">\lim_{p\rightarrow \inf}(\frac{[H]^p\vec{Z_0}}{\lambda_1^p})=a_1\vec{X_1}</formula><p><formula>\lambda_1</formula> 也可以通过<strong>瑞利商R</strong>得到:</p><figure><img src="media/img-20250319140426@-2110284857.png" alt="Img" /></figure><p>如果 <formula>[H]\vec{X}=\lambda\vec{X}</formula> ,R则为 <formula>\lambda</formula> .进一步,第i次迭代中计算R:</p><figure><img src="media/img-20250319140616@-366069336.png" alt="Img" /></figure><p>只要相邻两次迭代的R相差小于tol 值,那么 <formula>\lambda_1=R_i</formula></p><h4 id="计算最小特征值">计算最小特征值</h4><p>我们可以通过计算下式来获得最小特征值与相应的特征向量:</p><figure><img src="media/img-20250319141004@318077024.png" alt="Img" /></figure><p>计算方法:
1)左乘H的逆,可得:</p><figure><img src="media/img-20250319141200@2087261182.png" alt="Img" /></figure><p>2)改写为:</p><p><img src="media/img-20250319141231@-2118471076.png" alt="Img" />
<img src="media/img-20250319141240@-2090992262.png" alt="Img" /></p><p>这意味着可以像计算最大特征值那样计算[H]的最小特征值.</p><blockquote><p>注意:计算最小特征值之前,要先找到[H]的逆,虽然会有额外的计算,但在某些情况下是比较好的办法.</p></blockquote><h4 id="计算中间特征值">计算中间特征值</h4><p>对 <formula>\vec{X_1}</formula> 进行归一化,令X1的第一个分量 <formula>x_1=1</formula> ,即:</p><figure><img src="media/img-20250319141745@-1945758940.png" alt="Img" /></figure><p>记 <formula>\vec{r}^T</formula> 为[H]的第一行元素, <formula>\vec{r}^T=\{h_{11},h_{12},...,h_{1n},\}</formula> ,那么有:</p><figure><img src="media/img-20250319142532@-2007463839.png" alt="Img" /></figure><p>令另一个主特征值为 <formula>\lambda_2</formula> ,归一化 <formula>\vec{X_2}</formula> ,令 <formula>\vec{X_2}</formula> 的第一个分量为1.0:</p><figure><img src="media/img-20250319143243@1395203261.png" alt="Img" /></figure><figure><img src="media/img-20250319143303@-2124647328.png" alt="Img" /></figure><p>eq7.56表明: <formula>\lambda_2</formula> 是 <formula>[H]-\left [  \underset{\sim }{H}  \right ]</formula> 的特征值; <formula>[H]-\left [  \underset{\sim }{H}  \right ]</formula> 的第一行全为0,而X2-X1的第一个元素为0;通过删去 <formula>[H]-\left [  \underset{\sim }{H}  \right ]</formula> 的第一行和第一列可以获得 <formula>[H_2]</formula> ,然后,计算 <formula>[H_2]</formula> 的主特征值和特征向量,并且把特征向量的第一个元素置0,可以获得Z1.可以发现X2-X1必然是Z1的倍数,即:</p><figure><img src="media/img-20250319144648@-1896968955.png" alt="Img" /></figure><p>乘子a为:</p><figure><img src="media/img-20250319144806@-238295031.png" alt="Img" /></figure><p>至此,特征向量X2就可以得到了, <formula>\lambda_2</formula> 同堂可以得到.按照类似的过程循环接下去就可以得到其他特征值.</p><h2 id="瑞利里兹-子空间迭代法" data-location="1.4">瑞利里兹-子空间迭代法</h2><p>这是一个求解大规模自由度系统的少量特征值的有效算法;下面给出算法的简要介绍,详细细节见K.J. Bathe, E.L. Wilson, Large eigenvalue problems in dynamic analysis, Journal of Engineering Mechanics Division, Proceedings of ASCE 98 (EM6) (1972) 1471-1485.</p><h3 id="step01" data-location="1.4.1">Step01</h3><p>取q个初始迭代向量如下,其中p是要求的特征值个数. Bathe and Wilson发现q=min(2p,p+8)可以获得较好的收敛性;</p><figure><img src="media/img-20250319151515@-1317216058.png" alt="Img" /></figure><p>定义初始模态矩阵X0:</p><figure><img src="media/img-20250319151757@574154950.png" alt="Img" /></figure><p>此时迭代次数k=0.</p><blockquote><p>T.C. Cheu, C.P. Johnson, R.R. Craig Jr., Computer algorithms for calculating efﬁcient initial vectors for subspace iteration method, International Journal for Numerical Methods in Engineering 24 (1987) 1841-1848.给出了为子空间迭代法计算有效的初始向量的一种方法</p></blockquote><h3 id="step02" data-location="1.4.2">Step02</h3><p>现在需要利用子空间迭代法生成改进模态矩阵 <formula>X_{k+1}</formula> :</p><ol><li><formula>X_{k+1}</formula> 可由下式计算:</li></ol><figure><img src="media/img-20250319152534@481832546.png" alt="Img" /></figure><p>2)进一步计算:</p><figure><img src="media/img-20250319152555@540021027.png" alt="Img" /></figure><p>3)计算缩减系统的特征值和特征向量,并求得 <formula>Q_{k+1}</formula> 和 <formula>\lambda_{k+1}</formula> :</p><formula data-block="">[A_{k+1}][Q_{k+1}]=[B_{k+1}][Q_{k+1}]\lambda_{k+1}</formula><p>4)找到原始系统特征向量的改进近似值:</p><figure><img src="media/img-20250319153421@1305746430.png" alt="Img" /></figure><blockquote><p>It is assumed that the iteration vectors converging to the exact eigenvectors, <formula>\vec{X_1^(extra)},\vec{X_2^(extra)}.....</formula>  ,并且就是[X_{k+1}]的列向量
 It is assumed that the vectors in [X0] are not orthogonal to one of the required eigenvectors</p></blockquote><h3 id="step03" data-location="1.4.3">Step03</h3><p>如果相邻两次迭代过程k-1和k中求得的近似特征值 <formula>\lambda_i^{(k)} and\lambda_i^{(k+1)}</formula> 满足下式则认为收敛:</p><figure><img src="media/img-20250319154045@-442251235.png" alt="Img" /></figure><p><formula>\epsilon</formula> =1e-6;虽然迭代是用q个向量(q &gt; p)执行的,但收敛性仅在p个最小特征值预测的近似值上测量.</p><div class="container fullwidth" style="justify-items: end; text-align: end;"><p><a href="https://qinguoming.pages.dev/">返回 主页</a></p></div></main>
    <aside class="margin-area" id="margin-area-right"></aside>
  </body>
</html>
